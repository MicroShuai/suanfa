<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速排序算法可视化演示</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        
        .page-container {
            display: flex;
            gap: 20px;
            max-width: 2000px; /* 从1800px增加到2000px */
            margin: 0 auto; /* 整个页面居中 */
            justify-content: center;
        }
        
        .left-menu {
            width: 250px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .main-container {
            flex: 0 0 1200px; /* 从1000px增加到1200px */
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .sidebar {
            width: 450px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            max-height: 95vh;
            overflow-y: auto;
            position: sticky;
            top: 20px;
            text-align: left;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            width: 100%;
            font-size: 28px;
        }
        
        .algorithm-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .algorithm-item {
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            background-color: #f8f9fa;
        }
        
        .algorithm-item:hover {
            background-color: #e9ecef;
            transform: translateX(5px);
        }
        
        .algorithm-item.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            font-weight: bold;
        }
        
        .algorithm-item .name {
            font-size: 14px;
            font-weight: 500;
        }
        
        .algorithm-item .complexity {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }
        
        .left-menu h3 {
            color: #333;
            font-size: 18px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #007bff;
        }
        
        #chart {
            width: 100%;
            height: 63vh; /* 使用视窗高度的63% */
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            color: #1976d2;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .info {
            margin-top: 0;
            padding: 0;
            background-color: transparent;
            border: none;
        }
        
        .sidebar h3 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 18px;
        }
        
        .sidebar h4 {
            color: #555;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .sidebar .algorithm-section {
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .sidebar .core-idea-box {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin-bottom: 20px;
        }
        
        .sidebar .features-box {
            background-color: #d1ecf1;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #17a2b8;
            margin-top: 20px;
        }
        
        /* 响应式设计 */
        @media (max-width: 1600px) {
            .page-container {
                flex-direction: column;
                align-items: center;
                padding: 10px;
            }
            
            .left-menu {
                width: 100%;
                max-width: 1200px; /* 响应式时也增加最大宽度 */
                position: static;
                order: -1;
            }
            
            .main-container {
                flex: none;
                width: 100%;
                max-width: 1200px; /* 响应式时也增加最大宽度 */
            }
            
            .sidebar {
                width: 100%;
                max-width: 1200px; /* 响应式时也增加最大宽度 */
                max-height: none;
                overflow-y: visible;
                position: static;
            }
            
            .algorithm-list {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .algorithm-item {
                flex: 1;
                min-width: 200px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <!-- 左侧算法选择菜单 -->
        <div class="left-menu">
            <h3>🔍 选择排序算法</h3>
            <ul class="algorithm-list" id="algorithmList">
                <li class="algorithm-item active" data-algorithm="quickSort">
                    <div class="name">快速排序</div>
                    <div class="complexity">O(n log n)</div>
                </li>
                <li class="algorithm-item" data-algorithm="bubbleSort">
                    <div class="name">冒泡排序</div>
                    <div class="complexity">O(n²)</div>
                </li>
                <li class="algorithm-item" data-algorithm="insertionSort">
                    <div class="name">直接插入排序</div>
                    <div class="complexity">O(n²)</div>
                </li>
                <li class="algorithm-item" data-algorithm="selectionSort">
                    <div class="name">直接选择排序</div>
                    <div class="complexity">O(n²)</div>
                </li>
                <li class="algorithm-item" data-algorithm="mergeSort">
                    <div class="name">归并排序</div>
                    <div class="complexity">O(n log n)</div>
                </li>
                <li class="algorithm-item" data-algorithm="heapSort">
                    <div class="name">堆排序</div>
                    <div class="complexity">O(n log n)</div>
                </li>
                <li class="algorithm-item" data-algorithm="shellSort">
                    <div class="name">希尔排序</div>
                    <div class="complexity">O(n^1.3)~O(n²)</div>
                </li>
            </ul>
        </div>
        
        <!-- 主要内容区域 -->
        <div class="main-container">
            <h1>排序算法可视化演示</h1>
            
            <!-- 算法信息卡片 -->
            <div id="algorithmInfo" style="margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                <!-- 动态内容将在这里显示 -->
            </div>
            
            <div class="status" id="status">选择排序算法并点击"开始排序"按钮开始演示</div>
            <div id="chart"></div>
            
            <div class="controls">
                <button id="startBtn">开始排序</button>
                <button id="pauseBtn" disabled>暂停</button>
                <button id="resumeBtn" disabled>继续</button>
                <button id="resetBtn">重新生成数据</button>
                <button id="speedBtn">调整速度</button>
            </div>
        </div>

        <!-- 右侧算法说明面板 -->
        <div class="sidebar">
            <div class="info">
                <div id="algorithmDetails">
                    <!-- 动态算法详情将在这里显示 -->
                </div>
                
                <h4>📊 颜色图例说明：</h4>
                <ul id="colorLegend">
                    <li><span style="color: #f44336; font-weight: bold;">🔴 红色</span>：当前基准元素（Pivot）</li>
                    <li><span style="color: #ff9800; font-weight: bold;">🟡 橙色</span>：正在与基准比较的元素</li>
                    <li><span style="color: #4caf50; font-weight: bold;">🟢 绿色</span>：已分区到正确位置的元素</li>
                    <li><span style="color: #2196f3; font-weight: bold;">🔵 蓝色</span>：待处理的元素</li>
                    <li><span style="color: #9c27b0; font-weight: bold;">🟣 紫色</span>：已完全排序的部分</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 初始化ECharts实例
        var myChart = echarts.init(document.getElementById('chart'));
        
        // 排序算法信息数据库
        const algorithmsInfo = {
            quickSort: {
                name: '快速排序',
                timeComplexity: 'O(n log n)',
                stability: '不稳定',
                stabilityReason: '在分区过程中，相等元素的相对位置可能会改变。当交换元素时，原本在前面的相等元素可能被移到后面',
                advantages: '效率高，常用',
                disadvantages: '最坏退化为O(n²)，不稳定',
                coreIdea: '分治法 (Divide and Conquer)',
                description: '选择一个"基准元素"，将数组分成两部分，递归排序',
                steps: [
                    '选择基准：通常选择最后一个元素作为基准',
                    '分区操作：重新排列数组，使小元素在基准左边，大元素在右边',
                    '确定位置：基准元素现在处于最终排序后的正确位置',
                    '递归处理：对基准左边和右边的子数组重复执行上述过程',
                    '递归终止：当子数组长度为0或1时，排序完成'
                ],
                colors: {
                    pivot: { color: '#f44336', name: '基准元素' },
                    comparing: { color: '#ff9800', name: '正在比较的元素' },
                    partitioned: { color: '#4caf50', name: '已分区的元素' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' },
                    sorted: { color: '#9c27b0', name: '已排序的部分' }
                }
            },
            bubbleSort: {
                name: '冒泡排序',
                timeComplexity: 'O(n²)',
                stability: '稳定',
                stabilityReason: '只有当前面的元素严格大于后面的元素时才交换，相等元素不会交换位置，保持原有顺序',
                advantages: '实现简单',
                disadvantages: '效率低，基本淘汰',
                coreIdea: '相邻比较法',
                description: '重复遍历数组，比较相邻元素并交换，大元素像泡泡一样浮到后面',
                steps: [
                    '从第一个元素开始，比较相邻的两个元素',
                    '如果前面的元素比后面的大，就交换它们的位置',
                    '继续比较下一对相邻元素，直到数组末尾',
                    '一轮完成后，最大的元素已经"冒泡"到最后',
                    '重复上述过程，每轮确定一个最大元素的位置'
                ],
                colors: {
                    comparing: { color: '#ff9800', name: '正在比较的元素' },
                    swapping: { color: '#f44336', name: '需要交换的元素' },
                    sorted: { color: '#4caf50', name: '已排序的部分' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            },
            insertionSort: {
                name: '直接插入排序',
                timeComplexity: 'O(n²)',
                stability: '稳定',
                stabilityReason: '新元素总是插入到已排序部分中第一个大于它的元素前面，相等元素不会跨越，保持原有顺序',
                advantages: '实现简单，适用于基本有序数据',
                disadvantages: '效率低，数据量大时性能差',
                coreIdea: '插入法',
                description: '将数组分为已排序和未排序两部分，逐个将未排序元素插入到已排序部分的正确位置',
                steps: [
                    '将第一个元素视为已排序序列',
                    '取出下一个元素，从已排序序列末尾开始比较',
                    '找到合适的插入位置，将元素插入',
                    '重复上述过程，直到所有元素都被插入到正确位置',
                    '最终得到完全排序的数组'
                ],
                colors: {
                    current: { color: '#f44336', name: '当前插入的元素' },
                    comparing: { color: '#ff9800', name: '正在比较的元素' },
                    sorted: { color: '#4caf50', name: '已排序的部分' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            },
            selectionSort: {
                name: '直接选择排序',
                timeComplexity: 'O(n²)',
                stability: '不稳定',
                stabilityReason: '当找到最小元素并与当前位置交换时，可能会跨越相等的元素，破坏它们的原有顺序。例如：[3a, 2, 3b] → [2, 3b, 3a]',
                advantages: '交换次数少',
                disadvantages: '比较次数多',
                coreIdea: '选择法',
                description: '每次从未排序部分找到最小（或最大）元素，放到已排序部分的末尾',
                steps: [
                    '在未排序序列中找到最小元素',
                    '将其与第一个元素交换位置',
                    '在剩余未排序序列中继续寻找最小元素',
                    '将其与第二个元素交换位置',
                    '重复上述过程，直到所有元素排序完成'
                ],
                colors: {
                    current: { color: '#f44336', name: '当前位置' },
                    minimum: { color: '#ff9800', name: '当前最小元素' },
                    comparing: { color: '#ffeb3b', name: '正在比较的元素' },
                    sorted: { color: '#4caf50', name: '已排序的部分' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            },
            mergeSort: {
                name: '归并排序',
                timeComplexity: 'O(n log n)',
                stability: '稳定',
                stabilityReason: '在合并两个有序数组时，当遇到相等元素时，总是先取左子数组的元素，保证了相等元素的相对位置不变',
                advantages: '效率稳定，适合大数据量',
                disadvantages: '空间复杂度高',
                coreIdea: '分治法 (Divide and Conquer)',
                description: '将数组分成两半，递归排序后再合并两个有序数组',
                steps: [
                    '分解：将数组递归地分成两半，直到每个子数组只有一个元素',
                    '合并：将两个有序的子数组合并成一个有序数组',
                    '比较两个子数组的首元素，取较小者放入结果数组',
                    '重复比较过程，直到某个子数组为空',
                    '将剩余元素直接复制到结果数组中'
                ],
                colors: {
                    left: { color: '#f44336', name: '左子数组' },
                    right: { color: '#ff9800', name: '右子数组' },
                    merging: { color: '#ffeb3b', name: '正在合并' },
                    merged: { color: '#4caf50', name: '已合并' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            },
            heapSort: {
                name: '堆排序',
                timeComplexity: 'O(n log n)',
                stability: '不稳定',
                stabilityReason: '在构建堆和调整堆的过程中，元素会进行长距离跳跃式交换，相等元素的原有顺序会被破坏',
                advantages: '效率高，不占用额外空间',
                disadvantages: '实现略复杂',
                coreIdea: '堆结构',
                description: '利用堆这种数据结构，将数组构建成最大堆，然后逐个取出堆顶元素',
                steps: [
                    '构建最大堆：将无序数组调整成最大堆结构',
                    '交换：将堆顶（最大值）与末尾元素交换',
                    '调整：重新调整堆结构，使其满足最大堆性质',
                    '重复：重复交换和调整过程，直到堆的大小为1',
                    '完成：最终得到升序排列的数组'
                ],
                colors: {
                    root: { color: '#f44336', name: '堆顶元素' },
                    adjusting: { color: '#ff9800', name: '正在调整的元素' },
                    heap: { color: '#ffeb3b', name: '堆结构' },
                    sorted: { color: '#4caf50', name: '已排序的部分' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            },
            shellSort: {
                name: '希尔排序',
                timeComplexity: 'O(n^1.3) ~ O(n²)',
                stability: '不稳定',
                stabilityReason: '由于使用了较大的增量进行跨距离排序，相等元素可能会被分在不同的子序列中，破坏它们的原有顺序',
                advantages: '效率高于插入排序，适用于中等规模数据',
                disadvantages: '性能依赖增量序列',
                coreIdea: '分组插入法',
                description: '按照一定间隔将数组分组，对每组进行插入排序，逐步缩小间隔',
                steps: [
                    '选择增量序列：通常从n/2开始，每次减半',
                    '分组排序：按当前增量将数组分成若干组',
                    '插入排序：对每组分别进行插入排序',
                    '缩小增量：将增量减半，重复分组排序',
                    '最终排序：当增量为1时，进行最后一次插入排序'
                ],
                colors: {
                    gap: { color: '#f44336', name: '当前增量' },
                    comparing: { color: '#ff9800', name: '正在比较的元素' },
                    group: { color: '#ffeb3b', name: '同组元素' },
                    sorted: { color: '#4caf50', name: '局部有序' },
                    unsorted: { color: '#2196f3', name: '待处理的元素' }
                }
            }
        };
        
        // 排序算法可视化类
        class SortVisualizer {
            constructor() {
                this.array = this.generateRandomArray(12);
                this.originalArray = [...this.array];
                this.steps = [];
                this.currentStep = 0;
                this.isRunning = false;
                this.isPaused = false;
                this.speed = 1000;
                this.intervalId = null;
                this.currentAlgorithm = 'quickSort';
                
                this.initChart();
                this.updateAlgorithmInfo();
            }
            
            generateRandomArray(size) {
                const arr = [];
                for (let i = 0; i < size; i++) {
                    arr.push(Math.floor(Math.random() * 100) + 10);
                }
                return arr;
            }
            
            updateAlgorithmInfo() {
                const info = algorithmsInfo[this.currentAlgorithm];
                
                // 更新算法信息卡片
                document.getElementById('algorithmInfo').innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                        <div>
                            <h3 style="margin: 0 0 10px 0; font-size: 24px;">${info.name}</h3>
                            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                                <span><strong>时间复杂度:</strong> ${info.timeComplexity}</span>
                                <span><strong>稳定性:</strong> ${info.stability}</span>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="color: #c8f7c5;"><strong>优势:</strong> ${info.advantages}</div>
                            <div style="color: #ffcccb;"><strong>劣势:</strong> ${info.disadvantages}</div>
                        </div>
                    </div>
                `;
                
                // 更新算法详情
                document.getElementById('algorithmDetails').innerHTML = `
                    <h3>🧠 ${info.name}的核心思想：</h3>
                    <div style="background-color: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 20px;">
                        <h4 style="margin-top: 0; color: #856404;">${info.coreIdea}</h4>
                        <p style="margin: 10px 0; line-height: 1.6;">${info.description}</p>
                    </div>
                    
                    <h4>🎯 算法步骤详解：</h4>
                    <ol style="line-height: 1.8;">
                        ${info.steps.map(step => `<li>${step}</li>`).join('')}
                    </ol>
                    
                    <div style="background-color: #d1ecf1; padding: 15px; border-radius: 8px; border-left: 4px solid #17a2b8; margin-top: 20px;">
                        <h4 style="margin-top: 0; color: #0c5460;">⚡ 算法特性：</h4>
                        <p style="margin: 10px 0; line-height: 1.6;">
                            • <strong>时间复杂度</strong>：${info.timeComplexity}<br>
                            • <strong>稳定性</strong>：${info.stability}<br>
                            • <strong>优势</strong>：${info.advantages}<br>
                            • <strong>劣势</strong>：${info.disadvantages}
                        </p>
                    </div>
                    
                    <div style="background-color: ${info.stability === '稳定' ? '#d4edda' : '#f8d7da'}; padding: 15px; border-radius: 8px; border-left: 4px solid ${info.stability === '稳定' ? '#28a745' : '#dc3545'}; margin-top: 20px;">
                        <h4 style="margin-top: 0; color: ${info.stability === '稳定' ? '#155724' : '#721c24'};">
                            🔍 稳定性详解 - ${info.stability}
                        </h4>
                        <p style="margin: 10px 0; line-height: 1.6; color: ${info.stability === '稳定' ? '#155724' : '#721c24'};">
                            ${info.stabilityReason}
                        </p>
                        <p style="margin: 10px 0; font-size: 14px; color: #666; line-height: 1.5;">
                            <strong>稳定性说明：</strong>排序算法的稳定性是指当待排序记录的关键字相同时，这些记录在排序后的相对次序保持不变。
                        </p>
                    </div>
                `;
                
                // 更新颜色图例
                const colorLegend = document.getElementById('colorLegend');
                colorLegend.innerHTML = '';
                Object.entries(info.colors).forEach(([key, colorInfo]) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span style="color: ${colorInfo.color}; font-weight: bold;">● ${colorInfo.name}</span>`;
                    colorLegend.appendChild(li);
                });
            }
            
            initChart() {
                const option = {
                    title: {
                        text: `${algorithmsInfo[this.currentAlgorithm].name}过程可视化`,
                        left: 'center',
                        top: 20,
                        textStyle: {
                            fontSize: 24, // 增加标题字体大小
                            fontWeight: 'bold'
                        }
                    },
                    xAxis: {
                        type: 'category',
                        data: this.array.map((_, index) => `位置${index}`),
                        axisLabel: {
                            rotate: 45,
                            fontSize: 14, // 增加坐标轴标签字体大小
                            color: '#333'
                        }
                    },
                    yAxis: {
                        type: 'value',
                        max: 120,
                        axisLabel: {
                            fontSize: 14, // 增加Y轴标签字体大小
                            color: '#333'
                        }
                    },
                    series: [{
                        type: 'bar',
                        data: this.array.map((value, index) => ({
                            value: value,
                            itemStyle: {
                                color: '#91cc75'
                            }
                        })),
                        label: {
                            show: true,
                            position: 'top',
                            formatter: '{c}',
                            fontSize: 16, // 增加数据标签字体大小
                            fontWeight: 'bold',
                            color: '#333' // 设置标签颜色为深色
                        },
                        animationDuration: 500
                    }],
                    grid: {
                        left: '8%',
                        right: '8%',
                        top: '15%', // 调整顶部边距
                        bottom: '15%' // 调整底部边距
                    }
                };
                
                myChart.setOption(option);
            }
            
            // 快速排序算法
            quickSort(arr, left = 0, right = arr.length - 1) {
                if (left >= right) return;
                
                this.steps.push({
                    array: [...arr],
                    action: `开始对位置 ${left} 到 ${right} 进行分区`,
                    highlights: { pivot: -1, comparing: -1, partitioned: [], sorted: [] }
                });
                
                const pivotIndex = this.partition(arr, left, right);
                
                this.steps.push({
                    array: [...arr],
                    action: `分区完成，基准元素 ${arr[pivotIndex]} 已就位`,
                    highlights: { pivot: pivotIndex, comparing: -1, partitioned: [pivotIndex], sorted: [] }
                });
                
                this.quickSort(arr, left, pivotIndex - 1);
                this.quickSort(arr, pivotIndex + 1, right);
            }
            
            partition(arr, left, right) {
                const pivotValue = arr[right];
                let i = left - 1;
                
                this.steps.push({
                    array: [...arr],
                    action: `选择位置 ${right} 的元素 ${pivotValue} 作为基准`,
                    highlights: { pivot: right, comparing: -1, partitioned: [], sorted: [] }
                });
                
                for (let j = left; j < right; j++) {
                    this.steps.push({
                        array: [...arr],
                        action: `比较元素 ${arr[j]} 与基准 ${pivotValue}`,
                        highlights: { pivot: right, comparing: j, partitioned: [], sorted: [] }
                    });
                    
                    if (arr[j] <= pivotValue) {
                        i++;
                        if (i !== j) {
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            this.steps.push({
                                array: [...arr],
                                action: `交换位置 ${i} 和 ${j} 的元素`,
                                highlights: { pivot: right, comparing: -1, partitioned: [], sorted: [] }
                            });
                        }
                    }
                }
                
                [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
                return i + 1;
            }
            
            // 冒泡排序算法
            bubbleSort(arr) {
                const n = arr.length;
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        this.steps.push({
                            array: [...arr],
                            action: `比较位置 ${j} 和 ${j + 1} 的元素`,
                            highlights: { comparing: [j, j + 1], sorted: Array.from({length: i}, (_, k) => n - 1 - k) }
                        });
                        
                        if (arr[j] > arr[j + 1]) {
                            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                            this.steps.push({
                                array: [...arr],
                                action: `交换位置 ${j} 和 ${j + 1} 的元素`,
                                highlights: { swapping: [j, j + 1], sorted: Array.from({length: i}, (_, k) => n - 1 - k) }
                            });
                        }
                    }
                }
            }
            
            // 直接插入排序算法
            insertionSort(arr) {
                const n = arr.length;
                for (let i = 1; i < n; i++) {
                    const current = arr[i];
                    let j = i - 1;
                    
                    this.steps.push({
                        array: [...arr],
                        action: `选择位置 ${i} 的元素 ${current} 进行插入`,
                        highlights: { current: i, sorted: Array.from({length: i}, (_, k) => k) }
                    });
                    
                    while (j >= 0 && arr[j] > current) {
                        this.steps.push({
                            array: [...arr],
                            action: `比较 ${arr[j]} 与 ${current}，需要后移`,
                            highlights: { current: i, comparing: j, sorted: Array.from({length: i}, (_, k) => k) }
                        });
                        
                        arr[j + 1] = arr[j];
                        j--;
                        
                        this.steps.push({
                            array: [...arr],
                            action: `将 ${arr[j + 2]} 后移一位`,
                            highlights: { current: i, comparing: j + 1, sorted: Array.from({length: i}, (_, k) => k) }
                        });
                    }
                    
                    arr[j + 1] = current;
                    this.steps.push({
                        array: [...arr],
                        action: `将 ${current} 插入到位置 ${j + 1}`,
                        highlights: { current: j + 1, sorted: Array.from({length: i + 1}, (_, k) => k) }
                    });
                }
            }
            
            // 直接选择排序算法
            selectionSort(arr) {
                const n = arr.length;
                for (let i = 0; i < n - 1; i++) {
                    let minIndex = i;
                    
                    this.steps.push({
                        array: [...arr],
                        action: `在位置 ${i} 到 ${n - 1} 中寻找最小元素`,
                        highlights: { current: i, minimum: minIndex, sorted: Array.from({length: i}, (_, k) => k) }
                    });
                    
                    for (let j = i + 1; j < n; j++) {
                        this.steps.push({
                            array: [...arr],
                            action: `比较 ${arr[j]} 与当前最小值 ${arr[minIndex]}`,
                            highlights: { current: i, minimum: minIndex, comparing: j, sorted: Array.from({length: i}, (_, k) => k) }
                        });
                        
                        if (arr[j] < arr[minIndex]) {
                            minIndex = j;
                            this.steps.push({
                                array: [...arr],
                                action: `找到新的最小值 ${arr[minIndex]} 在位置 ${minIndex}`,
                                highlights: { current: i, minimum: minIndex, sorted: Array.from({length: i}, (_, k) => k) }
                            });
                        }
                    }
                    
                    if (minIndex !== i) {
                        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
                        this.steps.push({
                            array: [...arr],
                            action: `交换位置 ${i} 和 ${minIndex} 的元素`,
                            highlights: { current: i, sorted: Array.from({length: i + 1}, (_, k) => k) }
                        });
                    }
                }
            }
            
            // 归并排序算法
            mergeSort(arr, left = 0, right = arr.length - 1) {
                if (left >= right) return;
                
                const mid = Math.floor((left + right) / 2);
                
                this.steps.push({
                    array: [...arr],
                    action: `分解：将位置 ${left}-${right} 分成 ${left}-${mid} 和 ${mid + 1}-${right}`,
                    highlights: { left: Array.from({length: mid - left + 1}, (_, i) => left + i), 
                                 right: Array.from({length: right - mid}, (_, i) => mid + 1 + i) }
                });
                
                this.mergeSort(arr, left, mid);
                this.mergeSort(arr, mid + 1, right);
                this.merge(arr, left, mid, right);
            }
            
            merge(arr, left, mid, right) {
                const leftArr = arr.slice(left, mid + 1);
                const rightArr = arr.slice(mid + 1, right + 1);
                let i = 0, j = 0, k = left;
                
                this.steps.push({
                    array: [...arr],
                    action: `开始合并左子数组 ${leftArr} 和右子数组 ${rightArr}`,
                    highlights: { merging: Array.from({length: right - left + 1}, (_, idx) => left + idx) }
                });
                
                while (i < leftArr.length && j < rightArr.length) {
                    if (leftArr[i] <= rightArr[j]) {
                        arr[k] = leftArr[i];
                        i++;
                    } else {
                        arr[k] = rightArr[j];
                        j++;
                    }
                    
                    this.steps.push({
                        array: [...arr],
                        action: `将 ${arr[k]} 放入位置 ${k}`,
                        highlights: { merged: Array.from({length: k - left + 1}, (_, idx) => left + idx) }
                    });
                    k++;
                }
                
                while (i < leftArr.length) {
                    arr[k] = leftArr[i];
                    this.steps.push({
                        array: [...arr],
                        action: `将剩余元素 ${arr[k]} 放入位置 ${k}`,
                        highlights: { merged: Array.from({length: k - left + 1}, (_, idx) => left + idx) }
                    });
                    i++;
                    k++;
                }
                
                while (j < rightArr.length) {
                    arr[k] = rightArr[j];
                    this.steps.push({
                        array: [...arr],
                        action: `将剩余元素 ${arr[k]} 放入位置 ${k}`,
                        highlights: { merged: Array.from({length: k - left + 1}, (_, idx) => left + idx) }
                    });
                    j++;
                    k++;
                }
            }
            
            // 堆排序算法
            heapSort(arr) {
                const n = arr.length;
                
                // 构建最大堆
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    this.heapify(arr, n, i);
                }
                
                this.steps.push({
                    array: [...arr],
                    action: '构建最大堆完成',
                    highlights: { heap: Array.from({length: n}, (_, i) => i) }
                });
                
                // 逐个提取元素
                for (let i = n - 1; i > 0; i--) {
                    [arr[0], arr[i]] = [arr[i], arr[0]];
                    
                    this.steps.push({
                        array: [...arr],
                        action: `将堆顶元素 ${arr[i]} 移到位置 ${i}`,
                        highlights: { root: 0, sorted: Array.from({length: n - i}, (_, k) => i + k) }
                    });
                    
                    this.heapify(arr, i, 0);
                }
            }
            
            heapify(arr, n, i) {
                let largest = i;
                let left = 2 * i + 1;
                let right = 2 * i + 2;
                
                if (left < n && arr[left] > arr[largest]) {
                    largest = left;
                }
                
                if (right < n && arr[right] > arr[largest]) {
                    largest = right;
                }
                
                if (largest !== i) {
                    this.steps.push({
                        array: [...arr],
                        action: `调整堆：交换位置 ${i} 和 ${largest}`,
                        highlights: { adjusting: [i, largest] }
                    });
                    
                    [arr[i], arr[largest]] = [arr[largest], arr[i]];
                    this.heapify(arr, n, largest);
                }
            }
            
            // 希尔排序算法
            shellSort(arr) {
                const n = arr.length;
                let gap = Math.floor(n / 2);
                
                while (gap > 0) {
                    this.steps.push({
                        array: [...arr],
                        action: `使用增量 ${gap} 进行分组排序`,
                        highlights: { gap: gap }
                    });
                    
                    for (let i = gap; i < n; i++) {
                        const temp = arr[i];
                        let j = i;
                        
                        this.steps.push({
                            array: [...arr],
                            action: `对间隔为 ${gap} 的元素进行插入排序`,
                            highlights: { comparing: [i], group: this.getGroupIndices(i, gap, n) }
                        });
                        
                        while (j >= gap && arr[j - gap] > temp) {
                            arr[j] = arr[j - gap];
                            j -= gap;
                            
                            this.steps.push({
                                array: [...arr],
                                action: `将元素后移 ${gap} 位`,
                                highlights: { comparing: [j], group: this.getGroupIndices(j, gap, n) }
                            });
                        }
                        
                        arr[j] = temp;
                    }
                    
                    gap = Math.floor(gap / 2);
                }
            }
            
            getGroupIndices(index, gap, n) {
                const group = [];
                const start = index % gap;
                for (let i = start; i < n; i += gap) {
                    group.push(i);
                }
                return group;
            }
            
            // 更新排序算法
            changeAlgorithm(algorithm) {
                this.stop();
                this.currentAlgorithm = algorithm;
                this.updateAlgorithmInfo();
                this.initChart();
                document.getElementById('status').textContent = '选择排序算法并点击"开始排序"按钮开始演示';
            }
            
            updateChart(step) {
                const info = algorithmsInfo[this.currentAlgorithm];
                const colors = step.array.map((_, index) => {
                    const highlights = step.highlights || {};
                    
                    if (this.currentAlgorithm === 'quickSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (index === highlights.pivot) return info.colors.pivot.color;
                        if (index === highlights.comparing) return info.colors.comparing.color;
                        if (highlights.partitioned && highlights.partitioned.includes(index)) return info.colors.partitioned.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'bubbleSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (highlights.swapping && highlights.swapping.includes(index)) return info.colors.swapping.color;
                        if (highlights.comparing && highlights.comparing.includes(index)) return info.colors.comparing.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'insertionSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (index === highlights.current) return info.colors.current.color;
                        if (index === highlights.comparing) return info.colors.comparing.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'selectionSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (index === highlights.current) return info.colors.current.color;
                        if (index === highlights.minimum) return info.colors.minimum.color;
                        if (index === highlights.comparing) return info.colors.comparing.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'mergeSort') {
                        if (highlights.merged && highlights.merged.includes(index)) return info.colors.merged.color;
                        if (highlights.merging && highlights.merging.includes(index)) return info.colors.merging.color;
                        if (highlights.left && highlights.left.includes(index)) return info.colors.left.color;
                        if (highlights.right && highlights.right.includes(index)) return info.colors.right.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'heapSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (index === highlights.root) return info.colors.root.color;
                        if (highlights.adjusting && highlights.adjusting.includes(index)) return info.colors.adjusting.color;
                        if (highlights.heap && highlights.heap.includes(index)) return info.colors.heap.color;
                        return info.colors.unsorted.color;
                    } else if (this.currentAlgorithm === 'shellSort') {
                        if (highlights.sorted && highlights.sorted.includes(index)) return info.colors.sorted.color;
                        if (highlights.comparing && highlights.comparing.includes(index)) return info.colors.comparing.color;
                        if (highlights.group && highlights.group.includes(index)) return info.colors.group.color;
                        return info.colors.unsorted.color;
                    }
                    
                    return '#2196f3';
                });
                
                const option = {
                    title: {
                        text: `${info.name}过程可视化`,
                        textStyle: {
                            fontSize: 24,
                            fontWeight: 'bold'
                        }
                    },
                    series: [{
                        data: step.array.map((value, index) => ({
                            value: value,
                            itemStyle: {
                                color: colors[index]
                            }
                        })),
                        label: {
                            show: true,
                            position: 'top',
                            formatter: '{c}',
                            fontSize: 16,
                            fontWeight: 'bold',
                            color: '#333'
                        }
                    }]
                };
                
                myChart.setOption(option);
                document.getElementById('status').textContent = step.action;
            }
            
            start() {
                if (this.isRunning) return;
                
                this.array = [...this.originalArray];
                this.steps = [];
                this.currentStep = 0;
                
                // 根据当前算法执行相应的排序
                if (this.currentAlgorithm === 'quickSort') {
                    this.quickSort([...this.array]);
                } else if (this.currentAlgorithm === 'bubbleSort') {
                    this.bubbleSort([...this.array]);
                } else if (this.currentAlgorithm === 'insertionSort') {
                    this.insertionSort([...this.array]);
                } else if (this.currentAlgorithm === 'selectionSort') {
                    this.selectionSort([...this.array]);
                } else if (this.currentAlgorithm === 'mergeSort') {
                    this.mergeSort([...this.array]);
                } else if (this.currentAlgorithm === 'heapSort') {
                    this.heapSort([...this.array]);
                } else if (this.currentAlgorithm === 'shellSort') {
                    this.shellSort([...this.array]);
                }
                
                // 添加完成步骤
                if (this.steps.length > 0) {
                    this.steps.push({
                        array: this.steps[this.steps.length - 1].array,
                        action: '排序完成！',
                        highlights: { sorted: Array.from({length: this.array.length}, (_, i) => i) }
                    });
                }
                
                this.isRunning = true;
                this.isPaused = false;
                this.play();
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('resetBtn').disabled = true;
            }
            
            play() {
                if (this.currentStep < this.steps.length && !this.isPaused) {
                    this.updateChart(this.steps[this.currentStep]);
                    this.currentStep++;
                    
                    this.intervalId = setTimeout(() => {
                        if (!this.isPaused) {
                            this.play();
                        }
                    }, this.speed);
                } else if (this.currentStep >= this.steps.length) {
                    this.stop();
                }
            }
            
            pause() {
                this.isPaused = true;
                if (this.intervalId) {
                    clearTimeout(this.intervalId);
                }
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('resumeBtn').disabled = false;
            }
            
            resume() {
                this.isPaused = false;
                this.play();
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('resumeBtn').disabled = true;
            }
            
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.intervalId) {
                    clearTimeout(this.intervalId);
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('resumeBtn').disabled = true;
                document.getElementById('resetBtn').disabled = false;
                
                if (this.currentStep >= this.steps.length) {
                    document.getElementById('status').textContent = '排序完成！';
                }
            }
            
            reset() {
                this.stop();
                this.array = this.generateRandomArray(12);
                this.originalArray = [...this.array];
                this.steps = [];
                this.currentStep = 0;
                this.initChart();
                document.getElementById('status').textContent = '选择排序算法并点击"开始排序"按钮开始演示';
            }
            
            changeSpeed() {
                const speeds = [2000, 1500, 1000, 500, 300];
                const speedNames = ['很慢', '慢', '正常', '快', '很快'];
                const currentIndex = speeds.indexOf(this.speed);
                const nextIndex = (currentIndex + 1) % speeds.length;
                this.speed = speeds[nextIndex];
                
                document.getElementById('speedBtn').textContent = `速度: ${speedNames[nextIndex]}`;
            }
        }
        
        // 创建排序可视化实例
        const visualizer = new SortVisualizer();
        
        // 左侧菜单点击事件
        document.getElementById('algorithmList').addEventListener('click', (e) => {
            const item = e.target.closest('.algorithm-item');
            if (item) {
                // 移除所有active类
                document.querySelectorAll('.algorithm-item').forEach(el => el.classList.remove('active'));
                // 添加active类到当前点击项
                item.classList.add('active');
                
                // 获取算法类型并切换
                const algorithm = item.getAttribute('data-algorithm');
                visualizer.changeAlgorithm(algorithm);
            }
        });
        
        // 按钮事件处理
        document.getElementById('startBtn').addEventListener('click', () => {
            visualizer.start();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            visualizer.pause();
        });
        
        document.getElementById('resumeBtn').addEventListener('click', () => {
            visualizer.resume();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            visualizer.reset();
        });
        
        document.getElementById('speedBtn').addEventListener('click', () => {
            visualizer.changeSpeed();
        });
        
        // 响应式处理
        window.addEventListener('resize', function() {
            myChart.resize();
        });
    </script>
</body>
</html>
